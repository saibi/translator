# 출처 및 번역 정보
- **원문 URL:** https://cursor.com/blog/agent-best-practices
- **번역:** Cursor AI (기술 문서 번역)
- **참고:** 예제 영상이 있는 곳에는 원문 링크를 두었습니다. 링크를 클릭하면 원문 페이지에서 해당 영상을 볼 수 있습니다.

---

# 에이전트와 함께 코딩할 때의 모범 사례

코딩 에이전트가 소프트웨어 개발 방식을 바꾸고 있습니다.

이제 모델은 몇 시간씩 돌아가며, 여러 파일에 걸친 대규모 리팩터링을 하고, 테스트가 통과할 때까지 반복할 수 있습니다. 다만 에이전트를 최대한 활용하려면 에이전트의 동작 방식을 이해하고, 새로운 사용 패턴을 익혀야 합니다.

이 가이드는 Cursor 에이전트를 활용하는 방법을 다룹니다. 에이전트 기반 코딩이 처음이든, Cursor 팀의 사용법을 배우고 싶든, 에이전트 코딩의 모범 사례를 함께 살펴보겠습니다.

## 에이전트 하네스 이해하기

에이전트 하네스(agent harness)는 다음 세 가지로 구성됩니다.

1. **지시(Instructions)**: 에이전트 행동을 이끄는 시스템 프롬프트와 규칙
2. **도구(Tools)**: 파일 편집, 코드베이스 검색, 터미널 실행 등
3. **사용자 메시지(User messages)**: 작업 방향을 정하는 여러분의 프롬프트와 후속 질문

Cursor 에이전트 하네스는 지원하는 각 모델마다 이 세 가지를 조율합니다. [지시 튜닝](https://cursor.com/blog/codex-model-harness)과 [도구](https://cursor.com/blog/semsearch)는 내부 평가와 외부 벤치마크를 바탕으로 모든 프론티어 모델에 맞춰 조정됩니다.

하네스가 중요한 이유는, 같은 프롬프트에도 모델마다 반응이 다르기 때문입니다. 셸 중심 워크플로에 많이 학습된 모델은 전용 검색 도구보다 `grep`을 선호할 수 있고, 다른 모델은 편집 후 린터 도구를 호출하라는 명시적 지시가 필요할 수 있습니다. Cursor 에이전트가 이를 대신 처리하므로, 새 모델이 나와도 여러분은 코딩에만 집중하면 됩니다.

## 계획부터 시작하기

가장 효과를 크게 보는 방법은 코딩 전에 계획을 세우는 것입니다.

시카고 대학교 [연구](https://cursor.com/blog/productivity)에 따르면, 경험 많은 개발자일수록 코드를 생성하기 전에 계획을 세우는 경향이 있습니다. 계획을 세우면 만들려는 것이 무엇인지 명확해지고, 에이전트가 나아갈 구체적인 목표가 생깁니다.

### 플랜 모드 사용하기

에이전트 입력창에서 `Shift+Tab`을 누르면 **플랜 모드(Plan Mode)**가 켜집니다. 이 모드에서는 바로 코드를 작성하지 않고, 에이전트가 다음을 수행합니다.

1. 코드베이스를 조사해 관련 파일을 찾고
2. 요구사항에 대해 명확히 질문하며
3. 파일 경로와 코드 참조가 포함된 구현 계획을 세운 뒤
4. 여러분의 승인을 받은 후에 구현합니다

**플랜 모드 예시:** 에이전트가 명확히 질문하고 검토 가능한 계획을 만듭니다.

▶ [예제 영상 보기](https://cursor.com/blog/agent-best-practices#using-plan-mode)

계획은 마크다운 파일로 열리므로, 불필요한 단계 삭제, 접근 방식 수정, 에이전트가 놓친 맥락 추가 등을 직접 편집할 수 있습니다.

> **팁:** "Save to workspace"를 클릭하면 계획을 `.cursor/plans/`에 저장할 수 있습니다. 팀 문서화, 중단된 작업 재개, 같은 기능을 다루는 나중 에이전트를 위한 맥락 제공에 유용합니다.

모든 작업에 상세한 계획이 필요한 것은 아닙니다. 간단한 수정이나 여러 번 해본 작업은 에이전트에 바로 맡겨도 됩니다.

### 계획에서 다시 시작하기

에이전트가 원하는 결과와 다르게 구현했을 때는, 후속 프롬프트로 고치기보다 계획으로 돌아가는 편이 낫습니다.

변경 사항을 되돌리고, 필요한 내용을 더 구체적으로 반영해 계획을 다듬은 뒤 다시 실행하세요. 진행 중인 에이전트를 고치는 것보다 보통 더 빠르고, 결과도 더 깔끔합니다.

## 컨텍스트 관리하기

에이전트가 코드를 작성하는 것에 익숙해질수록, 각 에이전트가 작업을 끝내는 데 필요한 컨텍스트를 잘 주는 것이 중요해집니다.

### 에이전트가 컨텍스트를 찾게 하기

프롬프트에 모든 파일을 수동으로 태그할 필요는 없습니다.

Cursor 에이전트는 강력한 [검색 도구](https://cursor.com/blog/semsearch)를 갖추고 있어 필요할 때 컨텍스트를 가져옵니다. "인증 플로우"를 물어보면, 프롬프트에 그 단어가 없어도 에이전트가 `grep`과 시맨틱 검색으로 관련 파일을 찾습니다.

**인스턴트 grep으로 에이전트가 밀리초 단위로 코드베이스를 검색합니다.**

▶ [예제 영상 보기](https://cursor.com/blog/agent-best-practices#let-the-agent-find-context)

단순하게 가져가세요. 정확한 파일을 알고 있으면 태그하고, 모르면 에이전트가 찾게 두세요. 관련 없는 파일을 많이 넣으면 무엇이 중요한지 에이전트가 헷갈릴 수 있습니다.

`@Branch` 같은 도구로 "이 브랜치의 변경 사항을 리뷰해 줘", "지금 뭘 하고 있어?"처럼 현재 작업 맥락을 자연스럽게 전달할 수도 있습니다.

### 새 대화를 시작할 시점

자주 묻는 질문 중 하나는 "이 대화를 이어갈까, 새로 시작할까?"입니다.

**다음처럼 할 때는 새 대화를 시작하세요.**

- 다른 작업이나 기능으로 넘어갈 때
- 에이전트가 헷갈려하거나 같은 실수를 반복할 때
- 한 단위의 작업을 마쳤을 때

**다음처럼 할 때는 대화를 이어가세요.**

- 같은 기능을 반복해서 다듬을 때
- 에이전트가 앞선 대화의 맥락이 필요할 때
- 방금 만든 것을 디버깅할 때

대화가 길어지면 에이전트가 초점을 잃을 수 있습니다. 여러 턴과 요약이 쌓이면 컨텍스트에 노이즈가 쌓이고, 에이전트가 산만해지거나 다른 작업으로 넘어갈 수 있습니다. 에이전트 효과가 떨어지는 게 느껴지면 새 대화를 시작할 때입니다.

### 과거 작업 참조하기

새 대화를 시작할 때는 전체 대화를 복사해 붙이지 말고 `@Past Chats`로 이전 작업을 참조하세요. 에이전트가 대화 기록에서 필요한 부분만 골라 읽을 수 있습니다.

전체 대화를 복제하는 것보다 훨씬 효율적입니다.

**이전 채팅을 참조해 이전 대화의 맥락을 가져옵니다.**

▶ [예제 영상 보기](https://cursor.com/blog/agent-best-practices#reference-past-work)

## 에이전트 확장하기

Cursor는 에이전트 동작을 맞춤 설정하는 두 가지 방식을 제공합니다. **규칙(Rules)**은 모든 대화에 적용되는 정적 맥락이고, **스킬(Skills)**은 필요할 때 에이전트가 쓸 수 있는 동적 기능입니다.

### 규칙: 프로젝트용 정적 맥락

규칙은 에이전트가 코드를 다루는 방식을 정하는 지속적인 지침입니다. 에이전트가 매 대화 시작 시 항상 보는 맥락이라고 보면 됩니다.

`.cursor/rules/`에 마크다운 파일로 규칙을 만드세요.

```markdown
# Commands

- `npm run build`: Build the project
- `npm run typecheck`: Run the typechecker
- `npm run test`: Run tests (prefer single test files for speed)

# Code style

- Use ES modules (import/export), not CommonJS (require)
- Destructure imports when possible: `import { foo } from 'bar'`
- See `components/Button.tsx` for canonical component structure

# Workflow

- Always typecheck after making a series of code changes
- API routes go in `app/api/` following existing patterns
```

규칙은 핵심만 담으세요. 실행할 명령, 따를 패턴, 코드베이스의 대표 예시로 가리킬 파일 정도면 됩니다. 내용 전체를 복사하기보다 파일을 참조하면 규칙이 짧고, 코드가 바뀌어도 오래된 정보가 덜 쌓입니다.

규칙에서 피할 것:

- 전체 스타일 가이드 복사 (린터 사용)
- 가능한 모든 명령 문서화 (에이전트가 흔한 도구는 앎)
- 거의 쓰이지 않는 엣지 케이스용 지시 추가

> **팁:** 단순하게 시작하세요. 에이전트가 같은 실수를 반복할 때만 규칙을 추가하고, 패턴을 이해하기 전에 과하게 최적화하지 마세요.

규칙을 git에 커밋하면 팀 전체가 활용할 수 있습니다. 에이전트가 실수할 때마다 규칙을 수정하고, GitHub 이슈나 PR에 `@cursor`를 태그해 에이전트가 규칙을 수정하게 할 수도 있습니다.

### 스킬: 동적 역량과 워크플로

[에이전트 스킬](https://cursor.com/docs/context/skills)은 에이전트가 할 수 있는 일을 넓혀 줍니다. 도메인 지식, 워크플로, 스크립트를 패키지로 만들어 필요할 때 에이전트가 호출할 수 있게 합니다.

스킬은 `SKILL.md` 파일로 정의하며, 다음을 포함할 수 있습니다.

- **커스텀 명령**: 에이전트 입력창에서 `/`로 실행하는 재사용 워크플로
- **훅(Hooks)**: 에이전트 동작 전·후에 실행되는 스크립트
- **도메인 지식**: 특정 작업에 대한 지시로, 필요 시 에이전트가 불러 쓸 수 있음

규칙이 항상 포함되는 것과 달리, 스킬은 에이전트가 관련 있다고 판단할 때만 동적으로 로드됩니다. 그래서 컨텍스트 창은 깔끔하게 유지하면서도 전문화된 기능에 접근할 수 있습니다.

### 예: 장시간 에이전트 루프

스킬을 이용해 목표를 달성할 때까지 오래 돌아가는 에이전트를 만드는 패턴이 유용합니다. 예를 들어, 모든 테스트가 통과할 때까지 에이전트가 계속 동작하도록 하는 훅을 만들 수 있습니다.

먼저 `.cursor/hooks.json`에 훅을 설정합니다.

```json
{
  "version": 1,
  "hooks": {
    "stop": [{ "command": "bun run .cursor/hooks/grind.ts" }]
  }
}
```

훅 스크립트(`.cursor/hooks/grind.ts`)는 stdin으로 컨텍스트를 받고, 루프를 이어가기 위해 `followup_message`를 반환합니다.

```typescript
import { readFileSync, existsSync } from "fs";

interface StopHookInput {
  conversation_id: string;
  status: "completed" | "aborted" | "error";
  loop_count: number;
}

const input: StopHookInput = await Bun.stdin.json();
const MAX_ITERATIONS = 5;

if (input.status !== "completed" || input.loop_count >= MAX_ITERATIONS) {
  console.log(JSON.stringify({}));
  process.exit(0);
}

const scratchpad = existsSync(".cursor/scratchpad.md")
  ? readFileSync(".cursor/scratchpad.md", "utf-8")
  : "";

if (scratchpad.includes("DONE")) {
  console.log(JSON.stringify({}));
} else {
  console.log(JSON.stringify({
    followup_message: `[Iteration ${input.loop_count + 1}/${MAX_ITERATIONS}] Continue working. Update .cursor/scratchpad.md with DONE when complete.`
  }));
}
```

이 패턴은 다음에 유용합니다.

- 모든 테스트가 통과할 때까지 실행(및 수정)하기
- UI가 디자인 목업과 맞을 때까지 반복하기
- 성공 여부를 검증할 수 있는 목표 지향 작업

> **팁:** 훅이 있는 스킬은 보안 도구, 시크릿 매니저, 관측 플랫폼과 연동할 수 있습니다. [훅 문서](https://cursor.com/docs/agent/hooks)에서 파트너 연동을 참고하세요.

> 에이전트 스킬은 현재 나이트리 채널에서만 사용할 수 있습니다. Cursor 설정에서 Beta를 선택한 뒤 업데이트 채널을 Nightly로 바꾸고 재시작하세요.

코딩 외에도 [MCP(Model Context Protocol)](https://cursor.com/docs/context/mcp/directory)로 에이전트를 Slack 메시지, Datadog 로그 조사, Sentry 오류 디버깅, DB 쿼리 등 일상에서 쓰는 도구와 연결할 수 있습니다.

## 이미지 포함하기

에이전트는 프롬프트에 넣은 이미지를 그대로 처리할 수 있습니다. 스크린샷을 붙여 넣거나, 디자인 파일을 끌어다 넣거나, 이미지 경로를 참조하면 됩니다.

### 디자인을 코드로

디자인 목업을 붙여 넣고 에이전트에게 구현해 달라고 하세요. 에이전트는 이미지를 보고 레이아웃, 색상, 간격을 맞출 수 있습니다. [Figma MCP 서버](https://cursor.com/docs/context/mcp/directory)를 쓸 수도 있습니다.

### 시각적 디버깅

에러 상태나 예상 밖 UI를 스크린샷으로 찍어 에이전트에게 조사해 달라고 하세요. 글로 설명하는 것보다 훨씬 빠를 때가 많습니다.

에이전트는 브라우저를 조작해 스크린샷을 찍고, 앱을 테스트하고, 시각적 변경을 검증할 수도 있습니다. 자세한 내용은 [브라우저 문서](https://cursor.com/docs/agent/browser)를 참고하세요.

**브라우저 사이드바로 디자인과 코딩을 동시에 할 수 있습니다.**

▶ [예제 영상 보기](https://cursor.com/blog/agent-best-practices#including-images)

## 자주 쓰는 워크플로

다양한 작업에 잘 맞는 에이전트 패턴입니다.

### 테스트 주도 개발

에이전트가 코드를 작성하고, 테스트를 실행하고, 자동으로 반복할 수 있습니다.

1. **에이전트에게 테스트 작성 요청** — 기대 입력/출력 쌍을 기준으로. TDD를 한다고 명시하면 아직 없는 기능에 대한 목 구현을 만들지 않습니다.
2. **테스트를 실행해 실패하는지 확인하라고 지시** — 이 단계에서는 구현 코드를 작성하지 말라고 명시하세요.
3. **테스트에 만족하면 커밋**하세요.
4. **테스트를 통과시키는 코드를 작성하라고 요청** — 테스트는 수정하지 말고, 모든 테스트가 통과할 때까지 반복하라고 하세요.
5. **구현에 만족하면 커밋**하세요.

에이전트는 명확한 목표가 있을 때 가장 잘 동작합니다. 테스트가 있으면 에이전트가 변경을 하고, 결과를 평가하고, 성공할 때까지 점진적으로 개선할 수 있습니다.

### 코드베이스 이해하기

새 코드베이스에 합류했을 때 에이전트로 학습하고 탐색하세요. 팀원에게 할 법한 질문을 그대로 하면 됩니다.

- "이 프로젝트에서 로깅은 어떻게 되나요?"
- "새 API 엔드포인트는 어떻게 추가하나요?"
- "`CustomerOnboardingFlow`가 다루는 엣지 케이스는 무엇인가요?"
- "1738번 줄에서 `createUser()` 대신 `setUser()`를 쓰는 이유가 뭔가요?"

에이전트는 `grep`과 시맨틱 검색으로 코드베이스를 살펴보고 답을 찾습니다. 낯선 코드에 빨리 적응하는 방법 중 하나입니다.

### Git 워크플로

에이전트는 git 히스토리 검색, 머지 충돌 해결, git 워크플로 자동화를 할 수 있습니다.

예: 현재 변경 사항으로 커밋·푸시·PR 생성까지 하는 `/pr` 명령:

```
Create a pull request for the current changes.

1. Look at the staged and unstaged changes with `git diff`
2. Write a clear commit message based on what changed
3. Commit and push to the current branch
4. Use `gh pr create` to open a pull request with title/description
5. Return the PR URL when done
```

하루에 자주 쓰는 워크플로에는 명령이 잘 맞습니다. `.cursor/commands/`에 마크다운 파일로 저장하고 git에 넣어 두면 팀 전체가 쓸 수 있습니다.

저희가 쓰는 다른 명령 예시:

- `/fix-issue [number]`: `gh issue view`로 이슈 내용을 가져와 관련 코드를 찾고, 수정한 뒤 PR 생성
- `/review`: 린터 실행, 흔한 이슈 확인, 주의할 점 요약
- `/update-deps`: 오래된 의존성 확인 후 하나씩 업데이트하고, 매번 테스트 실행

에이전트가 이 명령을 스스로 실행할 수 있으므로, `/` 한 번으로 여러 단계 워크플로를 위임할 수 있습니다.

## 코드 리뷰하기

AI가 만든 코드는 리뷰가 필요하고, Cursor는 여러 옵션을 제공합니다.

### 생성 중에

에이전트가 작업하는 것을 보세요. diff 뷰에서 변경 사항이 실시간으로 보입니다. 잘못된 방향으로 가는 것 같으면 **Escape**로 중단하고 방향을 바꿀 수 있습니다.

### 에이전트 리뷰

에이전트가 끝난 뒤 **Review** → **Find Issues**를 클릭하면 전용 리뷰를 돌립니다. 에이전트가 제안된 수정을 줄 단위로 분석하고 잠재적 문제를 짚어 줍니다.

로컬 변경 전체에 대해서는 Source Control 탭을 열고, main 브랜치와 비교해 Agent Review를 실행하세요.

**AI 코드 리뷰가 Cursor 안에서 버그를 찾고 수정합니다.**

▶ [예제 영상 보기](https://cursor.com/blog/agent-best-practices#reviewing-code)

### PR용 Bugbot

소스 컨트롤에 푸시하면 PR에 대한 자동 리뷰를 받을 수 있습니다. [Bugbot](https://cursor.com/docs/bugbot)이 고급 분석을 적용해 이슈를 일찍 잡고 개선점을 제안합니다.

### 아키텍처 다이어그램

큰 변경에는 에이전트에게 아키텍처 다이어그램 생성을 요청해 보세요. 예: "OAuth 제공자, 세션 관리, 토큰 갱신을 포함한 우리 인증 시스템의 데이터 플로우를 보여주는 Mermaid 다이어그램을 만들어 줘." 문서화에 유용하고, 코드 리뷰 전에 아키텍처 이슈를 드러낼 수 있습니다.

## 에이전트 병렬 실행하기

Cursor는 여러 에이전트를 서로 방해하지 않고 병렬로 돌리기 쉽게 만들어 둡니다. 같은 문제를 여러 모델이 시도한 뒤 가장 좋은 결과를 고르면, 특히 어려운 작업에서 최종 결과가 눈에 띄게 나아집니다.

### 네이티브 워크트리 지원

Cursor는 병렬 에이전트를 위해 [git worktree](https://cursor.com/docs/configuration/worktrees)를 자동으로 만들고 관리합니다. 에이전트마다 별도 워크트리에서 격리된 파일과 변경으로 실행되므로, 서로 간섭 없이 편집·빌드·테스트할 수 있습니다.

워크트리에서 에이전트를 실행하려면 에이전트 드롭다운에서 worktree 옵션을 선택하세요. 에이전트가 끝나면 **Apply**를 눌러 작업 브랜치에 변경을 반영할 수 있습니다.

### 여러 모델을 동시에 실행하기

같은 프롬프트를 여러 모델에 동시에 보내는 패턴이 효과적입니다. 드롭다운에서 모델을 여러 개 선택하고 프롬프트를 보내면 결과를 나란히 비교할 수 있으며, Cursor가 추천하는 해법도 표시됩니다.

**멀티 에이전트 심사로 Cursor가 추천하는 해법을 보여 줍니다.**

▶ [예제 영상 보기](https://cursor.com/blog/agent-best-practices#running-agents-in-parallel)

다음 같은 경우에 특히 유용합니다.

- 서로 다른 접근을 시도할 수 있는 어려운 문제
- 모델군 간 코드 품질 비교
- 한 모델이 놓칠 수 있는 엣지 케이스 찾기

에이전트를 많이 병렬로 돌릴 때는 알림과 소리를 켜 두어 완료 시 알 수 있게 하세요.

## 클라우드 에이전트에 위임하기

클라우드 에이전트는 그렇지 않으면 할 일 목록에 넣었을 작업에 잘 맞습니다.

- 다른 작업 중에 생긴 버그 수정
- 최근 변경 사항 리팩터링
- 기존 코드에 대한 테스트 생성
- 문서 업데이트

작업에 따라 로컬 에이전트와 클라우드 에이전트를 바꿔 가며 쓸 수 있습니다. [cursor.com/agents](https://cursor.com/agents), Cursor 에디터, 또는 휴대폰에서 클라우드 에이전트를 시작할 수 있습니다. 책상에 없을 때도 웹이나 모바일로 세션을 확인할 수 있고, 클라우드 에이전트는 원격 샌드박스에서 돌아가므로 노트북을 닫아도 나중에 결과를 볼 수 있습니다.

**cursor.com/agents에서 여러 클라우드 에이전트 관리.**

▶ [예제 영상 보기](https://cursor.com/blog/agent-best-practices#delegating-to-cloud-agents)

클라우드 에이전트 동작 방식은 다음과 같습니다.

1. 작업과 관련 맥락을 설명합니다.
2. 에이전트가 저장소를 클론하고 브랜치를 만듭니다.
3. 자율적으로 작업한 뒤 완료 시 PR을 엽니다.
4. 완료되면 알림을 받습니다(Slack, 이메일, 웹 인터페이스).
5. 변경 사항을 리뷰한 뒤 원하면 머지합니다.

> **팁:** Slack에서 "@Cursor"로 에이전트를 트리거할 수 있습니다. [자세히 보기](https://cursor.com/docs/integrations/slack).

## 까다로운 버그용 디버그 모드

일반적인 에이전트 대화로 버그를 해결하기 어려울 때, **디버그 모드**는 다른 접근을 제공합니다.

추측으로 수정하는 대신, 디버그 모드는 다음을 합니다.

1. 무엇이 잘못됐을 수 있는지 여러 가설을 세우고
2. 로깅 문으로 코드에 계측을 넣으며
3. 버그를 재현하는 동안 런타임 데이터를 수집하고
4. 실제 동작을 분석해 원인을 좁히며
5. 근거에 따라 타깃 수정을 합니다

**에이전트 드롭다운의 디버그 모드.**

▶ [예제 영상 보기](https://cursor.com/blog/agent-best-practices#debug-mode-for-tricky-bugs)

다음에 특히 잘 맞습니다.

- 재현은 되는데 원인을 모르는 버그
- 레이스 컨디션·타이밍 이슈
- 성능 문제·메모리 누수
- 예전에는 되던 것이 깨진 회귀

재현 방법을 구체적으로 알려줄수록 에이전트가 넣는 계측이 더 유용해집니다.

## 워크플로 개선하기

에이전트를 가장 잘 쓰는 개발자들은 공통점이 있습니다.

**구체적인 프롬프트를 씁니다.** 구체적인 지시가 있을 때 에이전트 성공률이 크게 올라갑니다. "auth.ts에 테스트 추가해 줘"와 "auth.ts에 로그아웃 엣지 케이스를 다루는 테스트를 `__tests__/` 패턴으로 작성하고, 목은 쓰지 마"를 비교해 보세요.

**설정을 반복해서 다듬습니다.** 단순하게 시작하고, 에이전트가 같은 실수를 반복할 때만 규칙을 추가하고, 반복하고 싶은 워크플로를 정한 뒤에만 명령을 추가하세요. 패턴을 이해하기 전에 과하게 최적화하지 마세요.

**꼼꼼히 리뷰합니다.** AI가 만든 코드는 겉보기에 맞아도 미묘하게 틀릴 수 있습니다. diff를 읽고 신중히 리뷰하세요. 에이전트가 빨리 돌수록 리뷰 과정이 더 중요해집니다.

**검증 가능한 목표를 줍니다.** 에이전트는 알 수 없는 것은 고치지 못합니다. 타입이 있는 언어를 쓰고, 린터를 설정하고, 테스트를 작성하세요. 변경이 맞는지에 대한 명확한 신호를 주세요.

**에이전트를 협업할 수 있는 상대로 대합니다.** 계획을 요청하고, 설명을 요청하고, 마음에 들지 않는 접근에는 반론하세요.

에이전트는 빠르게 나아지고 있습니다. 새 모델과 함께 패턴도 바뀌겠지만, 오늘 코딩 에이전트와 함께 더 생산적으로 일하는 데 이 글이 도움이 되기를 바랍니다.

이 기법들을 써 보려면 [Cursor 에이전트](https://cursor.com/download)를 시작해 보세요.
